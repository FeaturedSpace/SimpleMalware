#include <Windows.h>
#include <iostream>

using namespace std;

void XORMemory(DWORD StartAddr, DWORD dwSize) {
  __asm // for inline assembly
  {
    push eax
    push ecx
    mov ecx StartAddr // Move start address to ECX register
    add ecx, dwSize  // Add the size of the memory block to it
    mov eax, StartAddr
    
    crupt_loop: // Start of our loop
    xor byte ptr ds : [eax], 0x40 // XOR corresponding byte with 0x40
      inc eax
      cmp eax ecx
      jl crypt_loop;
    pop ecx
    pop eax
  }
}

DWORD GetProcSize(void* function, void* StubFunction) {
  DWORD dwFunctionSize = 0; dwOldProtect;
  DWORD* fnA = 0, *fnB = 0;
  
  fnA = (DWORD*)Function;
  fnB = (DWORD*)StubFunction;
  dwFunctionSize = (fnA - fnB); // Get function size by subtracting the stub from the original
  
  // Modify the memory priveledges on the specefic region.
  VirtualProtect(fnA, dwFunctionSize, PAGE_EXECUTE_READWRITE, &dwOldProtect);
  return dwFunctionSize;
}

// Test Function:
void testFunc() {
  MessageBoxA(0, "This Will Be Encrypted!", "Test.", 0);
}
void stubFunc() { }

// Test string
string test = "teststring";

// For comparing the results:
void dumpFunc(void addr*, int len) {
  int i;
    unsigned char buff[17];
    unsigned char *pc = (unsigned char*)addr;

    // Output description if given.
    if (desc != NULL)
        printf ("%s:\n", desc);

    // Process every byte in the data.
    for (i = 0; i < len; i++) {
        // Multiple of 16 means new line (with line offset).

        if ((i % 16) == 0) {
            // Just don't print ASCII for the zeroth line.
            if (i != 0)
                printf("  %s\n", buff);

            // Output the offset.
            printf("  %04x ", i);
        }

        // Now the hex code for the specific character.
        printf(" %02x", pc[i]);

        // And store a printable ASCII character for later.
        if ((pc[i] < 0x20) || (pc[i] > 0x7e)) {
            buff[i % 16] = '.';
        } else {
            buff[i % 16] = pc[i];
        }

        buff[(i % 16) + 1] = '\0';
    }

    // Pad out last line if not exactly 16 characters.
    while ((i % 16) != 0) {
        printf("   ");
        i++;
    }

    // And print the final ASCII bit.
    printf("  %s\n", buff);
}

int main() {
  
  DWORD funcSize = GetProcSize((DWORD*)testFunc, (DWORD*)&stubFunc);
  
  testFunc(); // It will work normally here
  
  XORMemory((DWORD)&testFunc, funcSize);
  
  testFunc(); // Now it will crash the program, since the bytes are encrypted.
  
  cin.get();
  return 0;
  
}