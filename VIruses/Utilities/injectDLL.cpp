#include <Windows.h>
#include <TlHelp32.h>

using namespace std;

bool InjectDynamicLibrary(DWORD processId, char* dllPath) {
  
  // Open a new HANDLE to target process.
  HANDLE hTargetProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, processId);
  if(hTargetProcess) { // If the handle is valid.
    
    // Kernel32 is always mapped to the same address in each process
    // So we can just copy the address of it & LoadLibraryA in OUR process and
    // expect it to be the same in the remote process too.
    LPVOID LoadLibAddr = (LPVOID)GetProcAddress(GetModuleHandleA("kernel32.dll"), "LoadLibraryA");
    
    // We must allocate more memory in the target process to hold the path for our DLL in it's addresspace.
    LPVOID LoadPath = VirtualAlocEx(hTargetProcess, 0, strlen(dllPath), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));
    
    // Create a thread in the target process that will call LoadLibraryA() with the dllpath as a parameter
    HANDLE RemoteThread = CreateRemoteThread(hTargetProcess, 0, 0, (LPTHREAD_START_ROUTINE)LoadLibAddr, LoadPath, 0, 0);
    
    // Wait for single operation to complete
    WaitForSingleObject(RemoteThread, INFINITE);
    
    // The path to the dll is no longer needed in the remote process, so we can just free the memory now.
    VirtualFreeEx(hTargetProcess, LoadPath, strlen(dllPath), MEM_RELEASE);
    CloseHandle(RemoteThread);
    CloseHandle(hTargetProcess);
    
    return true;
  }
  return false;
}

int main() {
  InjectDynamicLibrary(FindProcessId("chrome.exe"), "TargetDLL.dll");
}